import { GLContext } from "./global";
import { Mesh } from "./mesh";
import { Material } from "./material";
import { Color } from "../types/color";
import { mat4 } from "../types/mat4";
import { IRenderTarget } from "./render-target";
import { RenderTexture, DepthTexture, Texture } from "./texture";
import { vec2 } from "../types/vec2";
import { BuiltinAssets } from "../builtin-assets/assets";
import { UniformType, UniformValueType } from "./types";
import { Lines } from "./lines";
import { Rect } from "../types/rect";
import { BufferStructure, RenderBuffer } from "./buffer";
export declare class ZograRenderer {
    canvas: HTMLCanvasElement;
    gl: WebGL2RenderingContext;
    ctx: GLContext;
    assets: BuiltinAssets;
    private width;
    private height;
    viewProjectionMatrix: import("../types/mat4").Matrix4x4;
    viewMatrix: import("../types/mat4").Matrix4x4;
    projectionMatrix: import("../types/mat4").Matrix4x4;
    private target;
    private shader;
    private scissor;
    private globalUniforms;
    private globalTextures;
    private helperAssets;
    constructor(canvasElement: HTMLCanvasElement, width?: number, height?: number);
    use(): void;
    setSize(width: number, height: number): void;
    get canvasSize(): vec2;
    setViewProjection(view: Readonly<mat4>, projection: Readonly<mat4>): void;
    setRenderTarget(rt: IRenderTarget): void;
    setRenderTarget(colorAttachments: RenderTexture, depthAttachment?: DepthTexture): void;
    setRenderTarget(colorAttachments: RenderTexture[], depthAttachment?: DepthTexture): void;
    clear(color?: Color, clearDepth?: boolean): void;
    blit(src: Texture | null, dst: IRenderTarget | RenderTexture | RenderTexture[], material?: Material, srcRect?: Rect, dstRect?: Rect): void;
    private useShader;
    private setupTransforms;
    private setupGlobalUniforms;
    drawMeshInstance<T extends BufferStructure>(mesh: Mesh, buffer: RenderBuffer<T>, material: Material, count: number): void;
    drawMeshProceduralInstance<T extends BufferStructure>(mesh: Mesh<T>, material: Material, count: number): void;
    drawMesh<T extends BufferStructure>(mesh: Mesh<T>, transform: Readonly<mat4>, material: Material): void;
    drawLines(lines: Lines, transform: mat4, material: Material): void;
    setGlobalUniform<T extends UniformType>(name: string, type: T, value: Readonly<UniformValueType<T>>): void;
    unsetGlobalUniform(name: string): void;
    private setupScissor;
}
